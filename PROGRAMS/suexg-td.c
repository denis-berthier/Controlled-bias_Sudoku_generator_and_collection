/*
 *  sudoku_gen.c
 *  
 *
 *
 */

/* short and fast sudoku-generator in C, compiled with gcc3.2 
executable at http://magictour.free.fr/suexg.exe 
 repost bugs,improvement-suggestions to sterten@aol.com 
 for some explanation of the solver 
http://magictour.free.fr/suexco.txt 
generates about 13 almost random sudokus per second with 1 GHz 
by starting from an empty grid, 
starting from a full grid is about 4 times faster 
the generated sudokus are locally minimal, so removing 
any clue results in a puzzle with multiple solutions 
this program is public domain 
*/ 

#include <stdio.h> 
#include <stdlib.h> 
#define MWC ((zr=36969*(zr&65535)+(zr>>16))^(wr=18000*(wr&65535)+(wr>>16))) 
unsigned zr=362436069, wr=521288629; 
int Rows[325],Cols[730],Row[325][10],Col[730][5],Ur[730],Uc[325],V[325],W[325]; 
int P[88],A[88],A0[88],C[88],I[88],Two[888]; 
int b,w,f,s1,m0,c1,c2,r1,l,i1,m1,m2,a,p,i,j,k,r,c,d,n=729,m=324,x,y,s; 
int mi1,mi2,q7,part,nt,nodes,seed,solutions,min,samples,sam1,clues; 
char L[11]=".123456789"; 
FILE *file; 
int solve(); 



int main(int argc,char*argv[]){ 
  if(argc<3){printf("\nusage:suexg random-seed z [file] \n\n"); 
       printf("     generates z locally minimal sudokus\n"); 
       printf("     use different numbers for seed to get different streams of sudokus\n"); 
       printf("     if file is given then for each puzzle in file z random minimal sudokus \n"); 
       printf("       are generated by deleting clues from the given puzzle\n"); 
       printf("     to redirect the sudokus to a file use e.g. : suexg 0 100 r >file\n"); 
       exit(1);} 

  sscanf(argv[1],"%i",&seed);zr^=seed;wr+=seed; 
  sscanf(argv[2],"%i",&samples); 
  if(argc>3)if((file=fopen(argv[3],"rb"))==NULL) 
                        {printf("\ncan't find file %s\n",argv[3]);exit(1);} 

for(i=0;i<888;i++){j=1;while(j<=i)j+=j;Two[i]=j-1;} 
for(i=1;i<=81;i++)A0[i]=0; 

r=0;for(x=1;x<=9;x++)for(y=1;y<=9;y++)for(s=1;s<=9;s++){ 
r++;Cols[r]=4;k=3; 
   Col[r][1]=x*9-9+y; 
   Col[r][2]=(k*((x-1)/k)+(y-1)/3)*9+s+81*1; 
   Col[r][3]=x*9-9+s+81*2; 
   Col[r][4]=y*9-9+s+81*3;} 
for(c=1;c<=m;c++)Rows[c]=0; 
for(r=1;r<=n;r++)for(c=1;c<=Cols[r];c++){ 
a=Col[r][c];Rows[a]++;Row[a][Rows[a]]=r;} 


m6:if(argc>3) 
   for(i=1;i<=81;i++){ 
   m6a:A0[i]=fgetc(file)-48;if(feof(file))exit(8); 
      if(A0[i]==-2)A0[i]=0;if(A0[i]<0 || A0[i]>9)goto m6a;} 

    sam1=0; 
m0s:sam1++;if(sam1>samples){if(argc>3)goto m6;exit(0);} 

m0:for(i=1;i<=81;i++)A[i]=A0[i];part=0;if(argc<4)solve(); 

part++; 
for(i=1;i<=81;i++){mr4:x=(MWC>>8)&127;if(x>=i)goto mr4;x++;P[i]=P[x];P[x]=i;} 
for(i1=1;i1<=81;i1++){s1=A[P[i1]];if(s1){A[P[i1]]=0;if(solve()>1)A[P[i1]]=s1;}} 
for(i=1;i<=81;i++)printf("%c",L[A[i]]);printf("\n"); 
goto m0s;} 



int solve(){ 
   for(i=0;i<=n;i++)Ur[i]=0;for(i=0;i<=m;i++)Uc[i]=0; 
   clues=0;for(i=1;i<=81;i++) 
     if(A[i]){clues++;r=i*9-9+A[i]; 
       for(j=1;j<=Cols[r];j++){d=Col[r][j];if(Uc[d])return -1;Uc[d]++; 
         for(k=1;k<=Rows[d];k++){Ur[Row[d][k]]++;}}} 
   for(c=1;c<=m;c++){V[c]=0;for(r=1;r<=Rows[c];r++)if(Ur[Row[c][r]]==0)V[c]++;} 
   i=clues;m0=0;m1=0;solutions=0;if(i==81)return 1; 
m2:i++;I[i]=0;min=n+1;if(i>81 || m0)goto m4; 
   if(m1){C[i]=m1;goto m3;} 
   w=0;for(c=1;c<=m;c++)if(!Uc[c]) {  if(V[c]<2){C[i]=c;goto m3;} 
          if(V[c]<=min){w++;W[w]=c;}; 
          if(V[c]<min){w=1;W[w]=c;min=V[c];} } 
mr:c2=MWC&Two[w];if(c2>=w)goto mr;C[i]=W[c2+1]; 
m3:c=C[i];I[i]++;if(I[i]>Rows[c])goto m4; 
   r=Row[c][I[i]];if(Ur[r])goto m3;m0=0;m1=0; 
   if(part==0){j=9;k=81;x=(r-1)/k+1;y=((r-1)%k)/j+1;s=(r-1)%j+1;A[x*9-9+y]=s;P[x*9-9+y]=i;} 
   for(j=1;j<=Cols[r];j++){c1=Col[r][j];Uc[c1]++;} 
   for(j=1;j<=Cols[r];j++){c1=Col[r][j]; 
      for(k=1;k<=Rows[c1];k++){r1=Row[c1][k];Ur[r1]++;if(Ur[r1]==1) 
         for(l=1;l<=Cols[r1];l++){c2=Col[r1][l];V[c2]--; 
            if(Uc[c2]+V[c2]<1)m0=c2;if(Uc[c2]==0 && V[c2]<2)m1=c2;}}} 
    if(i==81){solutions++;if(solutions>1)return 2;if(part==0)return 1;} 
    goto m2; 
m4:i--;c=C[i];r=Row[c][I[i]];if(i==clues)goto m9; 
   for(j=1;j<=Cols[r];j++){c1=Col[r][j];Uc[c1]--; 
      for(k=1;k<=Rows[c1];k++){r1=Row[c1][k];Ur[r1]--; 
         if(Ur[r1]==0)for(l=1;l<=Cols[r1];l++){c2=Col[r1][l];V[c2]++;}}} 
   if(i>clues)goto m3; 
m9:return solutions;} 
